// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

#include "Packages/jp.keijiro.noiseshader/Shader/ClassicNoise3D.hlsl"
#define EPS 0.00001

struct Particle
{
    float3 position;
    float3 velocity;
    float age;
};

RWStructuredBuffer<Particle> _Particles;
int _numParticles;
float _dt;
float _time;
float _maxAge;
float3 _initialVelocity;

float _noiseAmplitude;
float _noiseFrequency;
float _noiseSpeed;
float _drag;

uint rng_state;
uint rand_xorshift()
{
    // Xorshift algorithm from George Marsaglia's paper
    rng_state ^= (rng_state << 13);
    rng_state ^= (rng_state >> 17);
    rng_state ^= (rng_state << 5);
    return rng_state;
}

float randomFloat()
{
    return float(rand_xorshift()) * (1.0 / 4294967296.0);
}

void spawn(uint id)
{
    float x = randomFloat() * 2 - 1;
    float y = randomFloat() * 2 - 1;
    float z = randomFloat() * 2 - 1;

    _Particles[id].position = float3(x, y, z);
    _Particles[id].velocity = _initialVelocity;
    _Particles[id].age = randomFloat() * _maxAge;
}

// Cohesion
float nSize_Cohesion;
float attractionFactor;

// Separation
float nSize_Separation;
float repulsionFactor;

// Alignment
float alignmentFactor;

[numthreads(128,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float3 separationDir = float3(0, 0, 0);
    float neighbors = 0;

    // seperation : add a velocity based on the center of all boids in a neighborhod. needs a parameter for neighborhood size and repulsion factor.
    for (int i = 0; i < _numParticles; i++) {
        if (i == id.x) continue;
            
        float dist = distance(_Particles[id.x].position, _Particles[i].position);
        
        if(dist < nSize_Separation){
            separationDir += normalize(_Particles[id.x].position - _Particles[i].position);
            neighbors++;
        }
    }

    if(neighbors > 0){
        separationDir = separationDir /= neighbors;
        _Particles[id.x].velocity += separationDir * repulsionFactor;
    }

    // cohesion : add a velocity based on the center of all boids in a neighborhod. needs a parameter for neighborhood size and attraction factor.
    float3 cohesionCenter = float3(0, 0, 0);
    neighbors = 0;

    for (int i = 0; i < _numParticles; i++) {
        if (i == id.x) continue;
            
        float dist = distance(_Particles[id.x].position, _Particles[i].position);
        
        if(dist < nSize_Cohesion){
            cohesionCenter += _Particles[i].position;
            neighbors++;
        }
    }

    if(neighbors > 0){
        cohesionCenter = cohesionCenter /= neighbors;
        if(distance(cohesionCenter, _Particles[id.x].position) > 0.00001){
            float3 dir = cohesionCenter - _Particles[id.x].position; 
            _Particles[id.x].velocity += dir * attractionFactor;
        }
    }

    // alignment : movement direction (not speed) is influenced by neighbors direction. needs a alignment factor parameter.
    float3 averageDir = float3(0, 0, 0);

    neighbors = 0;
    for (int i = 0; i < _numParticles; i++) {
        float dist = distance(_Particles[id.x].position, _Particles[i].position);
            
        if(dist < nSize_Cohesion){
            averageDir += normalize(_Particles[i].velocity);
            neighbors++;
        }
    }

    if(neighbors > 0) {
        averageDir /= neighbors;

        float3 dir = normalize(_Particles[id.x].velocity);
        float3 s = length(_Particles[id.x].velocity);

        dir = lerp(dir, averageDir, alignmentFactor);

        _Particles[id.x].velocity = dir * s;
    }

    // The world should wrap so that the boid particles are always between 0 - 20 units in the x,y, and z dimensions.
    _Particles[id.x].position += _Particles[id.x].velocity *_dt;
    _Particles[id.x].velocity *= _drag;

    if(_Particles[id.x].position.x > 20) {
        _Particles[id.x].position.x -= 20;
    }

    if(_Particles[id.x].position.x < 0) {
        _Particles[id.x].position.x += 20;
    }

    if(_Particles[id.x].position.y > 20) {
        _Particles[id.x].position.y -= 20;
    }

    if(_Particles[id.x].position.y < 0) {
        _Particles[id.x].position.y += 20;
    }

    if(_Particles[id.x].position.z > 20) {
        _Particles[id.x].position.z -= 20;
    }

    if(_Particles[id.x].position.z < 0) {
        _Particles[id.x].position.z += 20;
    }
}